require 'spec_helper'
require 'kramdown/man/cli'

require 'tempfile'

describe Kramdown::Man::CLI do
  describe "#initialize" do
    it "must default #output to nil" do
      expect(subject.output).to be(nil)
    end

    it "must initialize #option_parser" do
      expect(subject.option_parser).to be_kind_of(OptionParser)
    end
  end

  describe "#print_error" do
    let(:error) { "error!" }

    it "must print the program name and the error message to stderr" do
      expect {
        subject.print_error(error)
      }.to output("#{described_class::PROGRAM_NAME}: #{error}#{$/}").to_stderr
    end
  end

  describe "#print_backtrace" do
    let(:exception) { RuntimeError.new("error!") }

    it "must print the program name and the error message to stderr" do
      expect {
        subject.print_backtrace(exception)
      }.to output(
        %r{Oops! Looks like you've found a bug!
Please report the following text to: #{Regexp.escape(described_class::BUG_REPORT_URL)}

```}m
      ).to_stderr
    end
  end

  describe "#option_parser" do
    it do
      expect(subject.option_parser).to be_kind_of(OptionParser)
    end

    describe "#parse" do
      %w[-o --output].each do |flag|
        context "when given #{flag}" do
          let(:output) { 'man-page.1' }
          let(:argv)   { [flag, output] }

          before { subject.option_parser.parse(argv) }

          it "must set #output" do
            expect(subject.output).to eq(output)
          end
        end
      end

      %w[-V --version].each do |flag|
        context "when given #{flag}" do
          let(:argv) { [flag] }

          it "must print the program name and the Kramdown::Man::VERSION" do
            expect(subject).to receive(:exit)

            expect {
              subject.option_parser.parse(argv)
            }.to output("#{described_class::PROGRAM_NAME} #{Kramdown::Man::VERSION}#{$/}").to_stdout
          end
        end
      end

      %w[-h --help].each do |flag|
        context "when given #{flag}" do
          let(:argv) { [flag] }

          it "must print the option paresr --help output" do
            expect(subject).to receive(:exit)

            expect {
              subject.option_parser.parse(argv)
            }.to output("#{subject.option_parser}").to_stdout
          end
        end
      end
    end
  end

  describe ".run" do
    subject { described_class }

    context "when Interrupt is raised" do
      before do
        expect_any_instance_of(described_class).to receive(:run).and_raise(Interrupt)
      end

      it "must exit with 130" do
        expect(subject.run([])).to eq(130)
      end
    end

    context "when Errno::EPIPE is raised" do
      before do
        expect_any_instance_of(described_class).to receive(:run).and_raise(Errno::EPIPE)
      end

      it "must exit with 0" do
        expect(subject.run([])).to eq(0)
      end
    end
  end

  let(:man_dir)       { File.join(__dir__,'..','man') }
  let(:markdown_file) { File.join(man_dir,'kramdown-man.1.md') }

  describe "#run" do
    context "when given a markdown file" do
      let(:argv) { [markdown_file] }

      context "and when the -o,--output option is also given" do
        let(:tempfile) { Tempfile.new(['kramdown-man-', '.1']) }
        let(:output)   { tempfile.path }

        let(:argv) { ['--output', output, markdown_file] }
        before { subject.option_parser.parse(argv) }

        it "must write the man page output to the output file" do
          subject.run(markdown_file)

          expect(File.read(output)).to match(/\A.\\" Generated by kramdown-man 1.0.0\n/)
        end
      end

      context "but STDOUT is a TTY" do
        before { expect($stdout).to receive(:tty?).and_return(true) }

        it "must open the man page output using the `man` command" do
          # TODO: need to test that IO.popen is actually being called
          expect(subject).to receive(:view_man_page).with(String)

          subject.run(argv)
        end
      end

      context "but STDOUT is not a TTY" do
        it "must print the man page to stdout" do
          expect {
            subject.run(argv)
          }.to output(/\A.\\" Generated by kramdown-man 1.0.0\n/).to_stdout
        end
      end

      context "but the given markdown file does not exist" do
        let(:markdown_file) { 'does/not/exist.md' }

        it "must print an error and return -1" do
          expect {
            expect(subject.run(argv)).to eq(-1)
          }.to output("kramdown-man: no such file or directory: #{markdown_file}#{$/}").to_stderr
        end
      end
    end

    context "when given no arguments" do
      let(:argv) { [] }

      it "must print an error and return -1" do
        expect {
          expect(subject.run(argv)).to eq(-1)
        }.to output("kramdown-man: a MARKDOWN_FILE argument is required#{$/}").to_stderr
      end
    end

    context "when too many arguments are given" do
      let(:argv) { ['one', 'two'] }

      it "must print an error and return -1" do
        expect {
          expect(subject.run(argv)).to eq(-1)
        }.to output("kramdown-man: too many arguments given#{$/}").to_stderr
      end
    end

    context "when given an invalid option" do
      let(:opt)  { '--foo' }
      let(:argv) { [opt] }

      it "must print 'kramdown-man: invalid option ...' to $stderr and exit with -1" do
        expect {
          expect(subject.run(argv)).to eq(-1)
        }.to output("kramdown-man: invalid option: #{opt}#{$/}").to_stderr
      end
    end

    context "when another type of Exception is raised" do
      let(:argv) { [markdown_file] }

      let(:exception) { RuntimeError.new("error!") }

      before do
        expect(Kramdown::Document).to receive(:new).and_raise(exception)
      end

      it "must print a backtrace and exit with -1" do
        expect {
          expect(subject.run(argv)).to eq(-1)
        }.to output(
          %r{Oops! Looks like you've found a bug!
Please report the following text to: #{Regexp.escape(described_class::BUG_REPORT_URL)}

```}m
        ).to_stderr
      end
    end
  end
end
